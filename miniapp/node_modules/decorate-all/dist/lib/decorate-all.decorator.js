"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecorateAll = void 0;
const copy_metadata_1 = require("./copy-metadata");
/**
 * Apply the given decorator to all class methods
 *
 * @param decorator Method decorator to apply to all methods of a class
 * @param {string[]} options.exclude array of method names that won't be decorated
 * @param {boolean} options.deep if true, also decorates methods of the extended classes (recusrively)
 */
const DecorateAll = (decorator, options = {}) => {
    return (target) => {
        var _a;
        let descriptors = Object.getOwnPropertyDescriptors(target.prototype);
        if (options.deep) {
            let base = Object.getPrototypeOf(target);
            while (base.prototype) {
                const baseDescriptors = Object.getOwnPropertyDescriptors(base.prototype);
                descriptors = Object.assign(Object.assign({}, baseDescriptors), descriptors);
                base = Object.getPrototypeOf(base);
            }
        }
        for (const [propName, descriptor] of Object.entries(descriptors)) {
            const isMethod = typeof descriptor.value == 'function' &&
                propName != 'constructor';
            if ((_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(propName))
                continue;
            if (propName.startsWith(options.excludePrefix))
                continue;
            if (!isMethod)
                continue;
            const originalMethod = descriptor.value;
            decorator(target, propName, descriptor);
            if (originalMethod != descriptor.value) {
                copy_metadata_1.copyMetadata(originalMethod, descriptor.value);
            }
            Object.defineProperty(target.prototype, propName, descriptor);
        }
    };
};
exports.DecorateAll = DecorateAll;
