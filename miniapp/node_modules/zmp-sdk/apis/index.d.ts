/**
 * @typedef {"none" | "wifi" | "cellular" | "unknown"} NetworkType
 */
declare enum NetworkType {
    /** No Network */
    none = "none",
    /** Wi-Fi Network */
    wifi = "wifi",
    /** Cellular Network (2g/3g/4g) */
    cellular = "cellular",
    /** Uncommon network types for Android */
    unknown = "unknown"
}
declare enum Events {
    AppPaused = "h5.event.paused",
    AppResumed = "h5.event.resumed",
    NetworkChanged = "h5.event.connection.changed",
    OnDataCallback = "h5.event.webview.result",
    OpenApp = "h5.event.open.mp",
    AppClose = "h5.event.action.close",
    PaymentCallback = "payment.callback",
    PaymentResult = "action.payment.result"
}

type AsyncCallbackFailObject = {
    code: number;
    message?: string | undefined;
    api?: string | undefined;
    [key: string]: any;
};
type AsyncCallback<T = any> = {
    success?: ((res: T) => void) | undefined;
    fail?: ((err: AsyncCallbackFailObject) => void) | undefined;
};
type AsyncVoidCallback = {
    success?: () => void;
    fail?: ((err: AsyncCallbackFailObject) => void) | undefined;
};
type GetLocationReturns = {
    /** latitude */
    latitude?: string;
    /** longitude */
    longitude?: string;
    /** timestamp */
    timestamp?: string;
    /** provider */
    provider?: string;
    token?: string;
};
interface SystemInfo {
    /** Mini app version */
    version: string;
    /** SDK version */
    apiVersion: string;
    /** Zalo version */
    zaloVersion: string;
    /** Client platform */
    platform: string;
    /** Language set in Zalo */
    language: string;
    /** Language set in Zalo */
    zaloLanguage: string;
    /** Theme set in Zalo */
    zaloTheme: string;
}
type SetStorageReturns = {
    errorKeys: string[];
};
type GetStorageReturns = {
    [key: string]: any;
};
type StorageInfo = {
    currentSize: number;
    limitSize: number;
};
type RemoveStorageReturns = {
    errorKeys: string[];
};
type GetUserInfoReturns = {
    userInfo: {
        id: string;
        name: string;
        avatar: string;
        idByOA?: string;
        isSensitive?: boolean;
    };
};
type GetNetworkTypeReturns = {
    networkType: NetworkType;
};
type iBeaconInfo = {
    /** The iBeacon device broadcast UUID. */
    uuid: string;
    /** The iBeacon device primary ID. */
    major: string;
    /** The iBeacon device secondary ID. */
    minor: string;
    /** The iBeacon device distance. */
    distance: number;
    /** The signal strength of the device. */
    rssi: number;
};
type GetBeaconDiscoveryReturns = {
    beacons: Array<iBeaconInfo>;
};
type ScanQRCodeReturns = {
    content: string;
};
type OpenPostFeedReturns = {
    status: 0 | 1;
    shareType: 0 | 1 | 2;
    numberOfUser: number;
};
type OpenShareSheetReturns = {
    status: 0 | 2 | 1;
    shareType: 0 | 2 | 1;
    numberOfUser: number;
};
type RequestCameraPermissionReturns = {
    userAllow: boolean;
    message: string;
};
type OpenBioAuthenticationReturns = {
    code: number;
    message: string;
    data: {
        domain: string;
        code: number;
        message: string;
        payToken: string;
    };
};
type CheckStateBioAuthenticationReturns = {
    bioState: string;
};
type KeepScreenReturns = {
    success: boolean;
};
type OpenWebviewReturns = {
    success: boolean;
};
type GetAppInfoReturns = {
    description: string;
    version: string;
    name: string;
    appUrl: string;
    qrCodeUrl: string;
    logoUrl?: string;
};
type GetPhoneNumberReturns = {
    number?: string;
    token?: string;
};
type OpenProfilePickerReturns = {
    users: {
        id: string;
        profile: {
            name: string;
            avatar: string;
        };
        code: number;
        message: string;
    }[];
};
type OpenMediaPickerReturns = {
    data: string;
};
/**
 * Context info
 */
type ContextInfo = {
    type?: string;
    id?: string;
};
type GetAuthCodeReturns = {
    authCode: string;
    authCodeVerify: string;
};
type GetZPITokenReturns = {
    utoken: string;
    gtoken: string;
    zpp: string;
    zpt: string;
};
type ChooseImageReturns = {
    filePaths: Array<string>;
    tempFiles: Array<{
        path: string;
        size: number;
    }>;
};
type CreateOrderReturns = {
    orderId: string;
};
type CheckTransactionReturns = {
    msg: string;
    orderId: string;
    transId: string;
    resultCode: number;
    transTime: string;
    createdAt: string;
};
type CreateOrderIAPReturns = {
    orderId: string;
};

declare function login(args?: AsyncCallback<string>): Promise<string>;

declare function getAccessToken(args?: AsyncCallback<string>): Promise<string>;

declare function getVersion(): string;

declare function getSystemInfo(): SystemInfo;

declare type Primitive = string | number | symbol | bigint | boolean | null | undefined;

declare namespace util {
    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
    export const assertEqual: <A, B>(val: AssertEqual<A, B>) => AssertEqual<A, B>;
    export function assertIs<T>(_arg: T): void;
    export function assertNever(_x: never): never;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };
    export const getValidEnumValues: (obj: any) => any[];
    export const objectValues: (obj: any) => any[];
    export const objectKeys: ObjectConstructor["keys"];
    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
    export type identity<T> = T;
    export type flatten<T> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noUndefined<T> = T extends undefined ? never : T;
    export const isInteger: NumberConstructor["isInteger"];
    export function joinValues<T extends any[]>(array: T, separator?: string): string;
    export const jsonStringifyReplacer: (_: string, value: any) => any;
    export {};
}
declare const ZodParsedType: {
    function: "function";
    number: "number";
    string: "string";
    nan: "nan";
    integer: "integer";
    float: "float";
    boolean: "boolean";
    date: "date";
    bigint: "bigint";
    symbol: "symbol";
    undefined: "undefined";
    null: "null";
    array: "array";
    object: "object";
    unknown: "unknown";
    promise: "promise";
    void: "void";
    never: "never";
    map: "map";
    set: "set";
};
declare type ZodParsedType = keyof typeof ZodParsedType;

declare type allKeys<T> = T extends any ? keyof T : never;
declare type typeToFlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in allKeys<T>]?: U[];
    };
};
declare const ZodIssueCode: {
    invalid_type: "invalid_type";
    invalid_literal: "invalid_literal";
    custom: "custom";
    invalid_union: "invalid_union";
    invalid_union_discriminator: "invalid_union_discriminator";
    invalid_enum_value: "invalid_enum_value";
    unrecognized_keys: "unrecognized_keys";
    invalid_arguments: "invalid_arguments";
    invalid_return_type: "invalid_return_type";
    invalid_date: "invalid_date";
    invalid_string: "invalid_string";
    too_small: "too_small";
    too_big: "too_big";
    invalid_intersection_types: "invalid_intersection_types";
    not_multiple_of: "not_multiple_of";
    not_finite: "not_finite";
};
declare type ZodIssueCode = keyof typeof ZodIssueCode;
declare type ZodIssueBase = {
    path: (string | number)[];
    message?: string;
};
interface ZodInvalidTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_type;
    expected: ZodParsedType;
    received: ZodParsedType;
}
interface ZodInvalidLiteralIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_literal;
    expected: unknown;
    received: unknown;
}
interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unrecognized_keys;
    keys: string[];
}
interface ZodInvalidUnionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union;
    unionErrors: ZodError[];
}
interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union_discriminator;
    options: Primitive[];
}
interface ZodInvalidEnumValueIssue extends ZodIssueBase {
    received: string | number;
    code: typeof ZodIssueCode.invalid_enum_value;
    options: (string | number)[];
}
interface ZodInvalidArgumentsIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_arguments;
    argumentsError: ZodError;
}
interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_return_type;
    returnTypeError: ZodError;
}
interface ZodInvalidDateIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_date;
}
declare type StringValidation = "email" | "url" | "uuid" | "regex" | "cuid" | "cuid2" | "datetime" | {
    startsWith: string;
} | {
    endsWith: string;
};
interface ZodInvalidStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_string;
    validation: StringValidation;
}
interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date";
}
interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date";
}
interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_intersection_types;
}
interface ZodNotMultipleOfIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_multiple_of;
    multipleOf: number;
}
interface ZodNotFiniteIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_finite;
}
interface ZodCustomIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params?: {
        [k: string]: any;
    };
}
declare type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;
declare type ZodIssue = ZodIssueOptionalMessage & {
    fatal?: boolean;
    message: string;
};
declare type ZodFormattedError<T, U = string> = {
    _errors: U[];
} & (NonNullable<T> extends [any, ...any[]] ? {
    [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U>;
} : NonNullable<T> extends any[] ? {
    [k: number]: ZodFormattedError<NonNullable<T>[number], U>;
} : NonNullable<T> extends object ? {
    [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U>;
} : unknown);
declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
    constructor(issues: ZodIssue[]);
    format(): ZodFormattedError<T>;
    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
    static create: (issues: ZodIssue[]) => ZodError<any>;
    toString(): string;
    get message(): string;
    get isEmpty(): boolean;
    addIssue: (sub: ZodIssue) => void;
    addIssues: (subs?: ZodIssue[]) => void;
    flatten(): typeToFlattenedError<T>;
    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
    get formErrors(): typeToFlattenedError<T, string>;
}
declare type stripPath<T extends object> = T extends any ? util.OmitKeys<T, "path"> : never;
declare type IssueData = stripPath<ZodIssueOptionalMessage> & {
    path?: (string | number)[];
    fatal?: boolean;
};
declare type ErrorMapCtx = {
    defaultError: string;
    data: any;
};
declare type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
    message: string;
};

declare type ParseParams = {
    path: (string | number)[];
    errorMap: ZodErrorMap;
    async: boolean;
};
declare type ParsePathComponent = string | number;
declare type ParsePath = ParsePathComponent[];
interface ParseContext {
    readonly common: {
        readonly issues: ZodIssue[];
        readonly contextualErrorMap?: ZodErrorMap;
        readonly async: boolean;
    };
    readonly path: ParsePath;
    readonly schemaErrorMap?: ZodErrorMap;
    readonly parent: ParseContext | null;
    readonly data: any;
    readonly parsedType: ZodParsedType;
}
declare type ParseInput = {
    data: any;
    path: (string | number)[];
    parent: ParseContext;
};
declare class ParseStatus {
    value: "aborted" | "dirty" | "valid";
    dirty(): void;
    abort(): void;
    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
    static mergeObjectAsync(status: ParseStatus, pairs: {
        key: ParseReturnType<any>;
        value: ParseReturnType<any>;
    }[]): Promise<SyncParseReturnType<any>>;
    static mergeObjectSync(status: ParseStatus, pairs: {
        key: SyncParseReturnType<any>;
        value: SyncParseReturnType<any>;
        alwaysSet?: boolean;
    }[]): SyncParseReturnType;
}
declare type INVALID = {
    status: "aborted";
};
declare const INVALID: INVALID;
declare type DIRTY<T> = {
    status: "dirty";
    value: T;
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
declare type OK<T> = {
    status: "valid";
    value: T;
};
declare const OK: <T>(value: T) => OK<T>;
declare type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
declare type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
declare type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;

declare namespace enumUtil {
    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;
    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
    export {};
}

declare namespace errorUtil {
    type ErrMessage = string | {
        message?: string;
    };
    const errToObj: (message?: ErrMessage | undefined) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage | undefined) => string | undefined;
}

declare namespace partialUtil {
    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<infer Shape, infer Params, infer Catchall> ? ZodObject<{
        [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;
    }, Params, Catchall> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}

declare type RefinementCtx = {
    addIssue: (arg: IssueData) => void;
    path: (string | number)[];
};
declare type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
declare type ZodTypeAny = ZodType<any, any, any>;
declare type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
declare type input<T extends ZodType<any, any, any>> = T["_input"];
declare type output<T extends ZodType<any, any, any>> = T["_output"];

declare type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
interface ZodTypeDef {
    errorMap?: ZodErrorMap;
    description?: string;
}
declare type RawCreateParams = {
    errorMap?: ZodErrorMap;
    invalid_type_error?: string;
    required_error?: string;
    description?: string;
} | undefined;
declare type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
};
declare type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
};
declare type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    get description(): string | undefined;
    abstract _parse(input: ParseInput): ParseReturnType<Output>;
    _getType(input: ParseInput): string;
    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;
    _processInputParams(input: ParseInput): {
        status: ParseStatus;
        ctx: ParseContext;
    };
    _parseSync(input: ParseInput): SyncParseReturnType<Output>;
    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
    parse(data: unknown, params?: Partial<ParseParams>): Output;
    safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
    parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;
    safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
    /** Alias of safeParseAsync */
    spa: (data: unknown, params?: Partial<ParseParams> | undefined) => Promise<SafeParseReturnType<Input, Output>>;
    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;
    _refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;
    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
    constructor(def: Def);
    optional(): ZodOptional<this>;
    nullable(): ZodNullable<this>;
    nullish(): ZodOptional<ZodNullable<this>>;
    array(): ZodArray<this>;
    promise(): ZodPromise<this>;
    or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;
    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;
    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
    default(def: util.noUndefined<Input>): ZodDefault<this>;
    default(def: () => util.noUndefined<Input>): ZodDefault<this>;
    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
    catch(def: Output): ZodCatch<this>;
    catch(def: () => Output): ZodCatch<this>;
    describe(description: string): this;
    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
    isOptional(): boolean;
    isNullable(): boolean;
}
declare type ZodStringCheck = {
    kind: "min";
    value: number;
    message?: string;
} | {
    kind: "max";
    value: number;
    message?: string;
} | {
    kind: "length";
    value: number;
    message?: string;
} | {
    kind: "email";
    message?: string;
} | {
    kind: "url";
    message?: string;
} | {
    kind: "uuid";
    message?: string;
} | {
    kind: "cuid";
    message?: string;
} | {
    kind: "cuid2";
    message?: string;
} | {
    kind: "startsWith";
    value: string;
    message?: string;
} | {
    kind: "endsWith";
    value: string;
    message?: string;
} | {
    kind: "regex";
    regex: RegExp;
    message?: string;
} | {
    kind: "trim";
    message?: string;
} | {
    kind: "datetime";
    offset: boolean;
    precision: number | null;
    message?: string;
};
interface ZodStringDef extends ZodTypeDef {
    checks: ZodStringCheck[];
    typeName: ZodFirstPartyTypeKind.ZodString;
    coerce: boolean;
}
declare class ZodString extends ZodType<string, ZodStringDef> {
    _parse(input: ParseInput): ParseReturnType<string>;
    protected _regex: (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage | undefined) => ZodEffects<this, string, string>;
    _addCheck(check: ZodStringCheck): ZodString;
    email(message?: errorUtil.ErrMessage): ZodString;
    url(message?: errorUtil.ErrMessage): ZodString;
    uuid(message?: errorUtil.ErrMessage): ZodString;
    cuid(message?: errorUtil.ErrMessage): ZodString;
    cuid2(message?: errorUtil.ErrMessage): ZodString;
    datetime(options?: string | {
        message?: string | undefined;
        precision?: number | null;
        offset?: boolean;
    }): ZodString;
    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;
    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;
    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;
    length(len: number, message?: errorUtil.ErrMessage): ZodString;
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty: (message?: errorUtil.ErrMessage | undefined) => ZodString;
    trim: () => ZodString;
    get isDatetime(): boolean;
    get isEmail(): boolean;
    get isURL(): boolean;
    get isUUID(): boolean;
    get isCUID(): boolean;
    get isCUID2(): boolean;
    get minLength(): number | null;
    get maxLength(): number | null;
    static create: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: true | undefined;
    }) | undefined) => ZodString;
}
declare type ZodNumberCheck = {
    kind: "min";
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: "max";
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: "int";
    message?: string;
} | {
    kind: "multipleOf";
    value: number;
    message?: string;
} | {
    kind: "finite";
    message?: string;
};
interface ZodNumberDef extends ZodTypeDef {
    checks: ZodNumberCheck[];
    typeName: ZodFirstPartyTypeKind.ZodNumber;
    coerce: boolean;
}
declare class ZodNumber extends ZodType<number, ZodNumberDef> {
    _parse(input: ParseInput): ParseReturnType<number>;
    static create: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodNumber;
    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    min: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;
    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    max: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;
    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    protected setLimit(kind: "min" | "max", value: number, inclusive: boolean, message?: string): ZodNumber;
    _addCheck(check: ZodNumberCheck): ZodNumber;
    int(message?: errorUtil.ErrMessage): ZodNumber;
    positive(message?: errorUtil.ErrMessage): ZodNumber;
    negative(message?: errorUtil.ErrMessage): ZodNumber;
    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;
    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;
    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    finite(message?: errorUtil.ErrMessage): ZodNumber;
    step: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;
    get minValue(): number | null;
    get maxValue(): number | null;
    get isInt(): boolean;
    get isFinite(): boolean;
}
interface ZodBooleanDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodBoolean;
    coerce: boolean;
}
declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
    _parse(input: ParseInput): ParseReturnType<boolean>;
    static create: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodBoolean;
}
interface ZodAnyDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodAny;
}
declare class ZodAny extends ZodType<any, ZodAnyDef> {
    _any: true;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: (params?: RawCreateParams) => ZodAny;
}
interface ZodUnknownDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodUnknown;
}
declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
    _unknown: true;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: (params?: RawCreateParams) => ZodUnknown;
}
interface ZodVoidDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodVoid;
}
declare class ZodVoid extends ZodType<void, ZodVoidDef> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: (params?: RawCreateParams) => ZodVoid;
}
interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodArray;
    exactLength: {
        value: number;
        message?: string;
    } | null;
    minLength: {
        value: number;
        message?: string;
    } | null;
    maxLength: {
        value: number;
        message?: string;
    } | null;
}
declare type ArrayCardinality = "many" | "atleastone";
declare type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [T["_output"], ...T["_output"][]] : T["_output"][];
declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [T["_input"], ...T["_input"][]] : T["_input"][]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get element(): T;
    min(minLength: number, message?: errorUtil.ErrMessage): this;
    max(maxLength: number, message?: errorUtil.ErrMessage): this;
    length(len: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone">;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, "many">;
}
declare namespace objectUtil {
    export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
        [k in Exclude<keyof U, keyof V>]: U[k];
    } & V;
    type optionalKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? k : never;
    }[keyof T];
    type requiredKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? never : k;
    }[keyof T];
    export type addQuestionMarks<T extends object> = Partial<Pick<T, optionalKeys<T>>> & Pick<T, requiredKeys<T>>;
    export type identity<T> = T;
    export type flatten<T extends object> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noNeverKeys<T extends ZodRawShape> = {
        [k in keyof T]: [T[k]] extends [never] ? never : k;
    }[keyof T];
    export type noNever<T extends ZodRawShape> = identity<{
        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
    }>;
    export const mergeShapes: <U extends ZodRawShape, T extends ZodRawShape>(first: U, second: T) => T & U;
    export {};
}
declare type extendShape<A, B> = util.flatten<Omit<A, keyof B> & B>;
declare type UnknownKeysParam = "passthrough" | "strict" | "strip";
interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodObject;
    shape: () => T;
    catchall: Catchall;
    unknownKeys: UnknownKeys;
}
declare type baseObjectOutputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_output"];
}>;
declare type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? objectUtil.flatten<baseObjectOutputType<Shape>> : objectUtil.flatten<baseObjectOutputType<Shape> & {
    [k: string]: Catchall["_output"];
}>;
declare type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
}>>;
declare type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? baseObjectInputType<Shape> : objectUtil.flatten<baseObjectInputType<Shape> & {
    [k: string]: Catchall["_input"];
}>;
declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
declare type objectKeyMask<Obj> = {
    [k in keyof Obj]?: true;
};
declare type noUnrecognized<Obj extends object, Shape extends object> = {
    [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
};
declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall>, Input = objectInputType<T, Catchall>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
    private _cached;
    _getCached(): {
        shape: T;
        keys: string[];
    };
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get shape(): T;
    strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall>;
    strip(): ZodObject<T, "strip", Catchall>;
    passthrough(): ZodObject<T, "passthrough", Catchall>;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    nonstrict: () => ZodObject<T, "passthrough", Catchall>;
    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * @deprecated Use `.extend` instead
     *  */
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, Catchall>, objectInputType<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, Catchall>>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject<extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;
    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
        [k in Key]: Schema;
    }, UnknownKeys, Catchall>;
    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;
    pick<Mask extends objectKeyMask<T>>(mask: noUnrecognized<Mask, T>): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
    omit<Mask extends objectKeyMask<T>>(mask: noUnrecognized<Mask, objectKeyMask<T>>): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;
    deepPartial(): partialUtil.DeepPartial<this>;
    partial(): ZodObject<{
        [k in keyof T]: ZodOptional<T[k]>;
    }, UnknownKeys, Catchall>;
    partial<Mask extends objectKeyMask<T>>(mask: noUnrecognized<Mask, objectKeyMask<T>>): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    required(): ZodObject<{
        [k in keyof T]: deoptional<T[k]>;
    }, UnknownKeys, Catchall>;
    required<Mask extends objectKeyMask<T>>(mask: noUnrecognized<Mask, objectKeyMask<T>>): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;
    static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, { [k in keyof baseObjectOutputType<T_1>]: baseObjectOutputType<T_1>[k]; }, { [k_2 in keyof objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>]: objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>[k_2]; }>;
    static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strict", ZodTypeAny, { [k in keyof baseObjectOutputType<T_1>]: baseObjectOutputType<T_1>[k]; }, { [k_2 in keyof objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>]: objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>[k_2]; }>;
    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, { [k in keyof baseObjectOutputType<T_1>]: baseObjectOutputType<T_1>[k]; }, { [k_2 in keyof objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>]: objectUtil.addQuestionMarks<{ [k_1 in keyof T_1]: T_1[k_1]["_input"]; }>[k_2]; }>;
}
declare type AnyZodObject = ZodObject<any, any, any>;
declare type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[
    ZodTypeAny,
    ZodTypeAny,
    ...ZodTypeAny[]
]>> extends ZodTypeDef {
    options: T;
    typeName: ZodFirstPartyTypeKind.ZodUnion;
}
declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    static create: <T_1 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;
}
interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    left: T;
    right: U;
    typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;
}
declare type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
declare type AssertArray<T> = T extends any[] ? T : never;
declare type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
}>;
declare type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]] : OutputTypeOfTuple<T>;
declare type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
}>;
declare type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest["_input"][]] : InputTypeOfTuple<T>;
interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
    items: T;
    rest: Rest;
    typeName: ZodFirstPartyTypeKind.ZodTuple;
}
declare type AnyZodTuple = ZodTuple<[
    ZodTypeAny,
    ...ZodTypeAny[]
] | [], ZodTypeAny | null>;
declare class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get items(): T;
    rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;
    static create: <T_1 extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;
}
interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    valueType: Value;
    keyType: Key;
    typeName: ZodFirstPartyTypeKind.ZodRecord;
}
declare type KeySchema = ZodType<string | number | symbol, any, any>;
declare type RecordType<K extends string | number | symbol, V> = [
    string
] extends [K] ? Record<K, V> : [number] extends [K] ? Record<K, V> : [symbol] extends [K] ? Record<K, V> : Partial<Record<K, V>>;
declare class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key["_output"], Value["_output"]>, ZodRecordDef<Key, Value>, RecordType<Key["_input"], Value["_input"]>> {
    get keySchema(): Key;
    get valueSchema(): Value;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get element(): Value;
    static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;
    static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;
}
interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple<any, any>, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    args: Args;
    returns: Returns;
    typeName: ZodFirstPartyTypeKind.ZodFunction;
}
declare type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_input"] extends Array<any> ? (...args: Args["_input"]) => Returns["_output"] : never;
declare type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_output"] extends Array<any> ? (...args: Args["_output"]) => Returns["_input"] : never;
declare class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {
    _parse(input: ParseInput): ParseReturnType<any>;
    parameters(): Args;
    returnType(): Returns;
    args<Items extends Parameters<typeof ZodTuple["create"]>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;
    returns<NewReturnType extends ZodType<any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;
    implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
    strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;
    validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;
    static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;
    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;
    static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;
    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
}
declare type EnumValues = [string, ...string[]];
declare type Values<T extends EnumValues> = {
    [k in T[number]]: k;
};
interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodEnum;
}
declare type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
declare type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;
declare type typecast<A, T> = A extends T ? A : never;
declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;
declare class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    get enum(): Values<T>;
    get Values(): Values<T>;
    get Enum(): Values<T>;
    extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract): ZodEnum<Writeable<ToExtract>>;
    exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;
    static create: typeof createZodEnum;
}
interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodPromise;
}
declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
    unwrap(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;
}
declare type RefinementEffect<T> = {
    type: "refinement";
    refinement: (arg: T, ctx: RefinementCtx) => any;
};
declare type TransformEffect<T> = {
    type: "transform";
    transform: (arg: T, ctx: RefinementCtx) => any;
};
declare type PreprocessEffect<T> = {
    type: "preprocess";
    transform: (arg: T) => any;
};
declare type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    schema: T;
    typeName: ZodFirstPartyTypeKind.ZodEffects;
    effect: Effect<any>;
}
declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
    innerType(): T;
    sourceType(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"], input<I>>;
    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
}

interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodOptional;
}
declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;
}
interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodNullable;
}
declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;
}
interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    defaultValue: () => util.noUndefined<T["_input"]>;
    typeName: ZodFirstPartyTypeKind.ZodDefault;
}
declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeDefault(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } & {
        default: T_1["_input"] | (() => util.noUndefined<T_1["_input"]>);
    }) => ZodDefault<T_1>;
}
interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny, C extends T["_input"] = T["_input"]> extends ZodTypeDef {
    innerType: T;
    catchValue: () => C;
    typeName: ZodFirstPartyTypeKind.ZodCatch;
}
declare class ZodCatch<T extends ZodTypeAny> extends ZodType<T["_output"], ZodCatchDef<T>, unknown> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeCatch(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } & {
        catch: T_1["_output"] | (() => T_1["_output"]);
    }) => ZodCatch<T_1>;
}
interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodBranded;
}
declare const BRAND: unique symbol;
declare type BRAND<T extends string | number | symbol> = {
    [BRAND]: {
        [k in T]: true;
    };
};
declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    unwrap(): T;
}
interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
    in: A;
    out: B;
    typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;
}
declare enum ZodFirstPartyTypeKind {
    ZodString = "ZodString",
    ZodNumber = "ZodNumber",
    ZodNaN = "ZodNaN",
    ZodBigInt = "ZodBigInt",
    ZodBoolean = "ZodBoolean",
    ZodDate = "ZodDate",
    ZodSymbol = "ZodSymbol",
    ZodUndefined = "ZodUndefined",
    ZodNull = "ZodNull",
    ZodAny = "ZodAny",
    ZodUnknown = "ZodUnknown",
    ZodNever = "ZodNever",
    ZodVoid = "ZodVoid",
    ZodArray = "ZodArray",
    ZodObject = "ZodObject",
    ZodUnion = "ZodUnion",
    ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    ZodIntersection = "ZodIntersection",
    ZodTuple = "ZodTuple",
    ZodRecord = "ZodRecord",
    ZodMap = "ZodMap",
    ZodSet = "ZodSet",
    ZodFunction = "ZodFunction",
    ZodLazy = "ZodLazy",
    ZodLiteral = "ZodLiteral",
    ZodEnum = "ZodEnum",
    ZodEffects = "ZodEffects",
    ZodNativeEnum = "ZodNativeEnum",
    ZodOptional = "ZodOptional",
    ZodNullable = "ZodNullable",
    ZodDefault = "ZodDefault",
    ZodCatch = "ZodCatch",
    ZodPromise = "ZodPromise",
    ZodBranded = "ZodBranded",
    ZodPipeline = "ZodPipeline"
}

declare const setNavigationBarTitleArgs: ZodOptional<ZodObject<{
    title: ZodString;
}, "strip", ZodTypeAny, {
    title: string;
}, {
    title: string;
}>>[];
declare function setNavigationBarTitle(args: AsyncVoidCallback & TypeOf<typeof setNavigationBarTitleArgs[0]>): Promise<void>;

declare const setNavigationBarColorArgs: ZodOptional<ZodObject<{
    color: ZodString;
    textColor: ZodOptional<ZodEnum<["black", "white"]>>;
    statusBarColor: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    textColor?: "black" | "white" | undefined;
    statusBarColor?: string | undefined;
    color: string;
}, {
    textColor?: "black" | "white" | undefined;
    statusBarColor?: string | undefined;
    color: string;
}>>[];
declare function setNavigationBarColor(args: AsyncVoidCallback & TypeOf<typeof setNavigationBarColorArgs[0]>): Promise<void>;

declare const setNavigationBarLeftButtonArgs: ZodOptional<ZodObject<{
    type: ZodEnum<["none", "back", "home", "both"]>;
}, "strip", ZodTypeAny, {
    type: "none" | "home" | "both" | "back";
}, {
    type: "none" | "home" | "both" | "back";
}>>[];
declare function setNavigationBarLeftButton(args: AsyncVoidCallback & TypeOf<typeof setNavigationBarLeftButtonArgs[0]>): Promise<void>;

declare const setStorageArgs: ZodOptional<ZodObject<{
    data: ZodRecord<ZodString, ZodAny>;
}, "strip", ZodTypeAny, {
    data: Record<string, any>;
}, {
    data: Record<string, any>;
}>>[];
declare function setStorage(args: AsyncCallback<SetStorageReturns> & TypeOf<typeof setStorageArgs[0]>): Promise<SetStorageReturns>;

declare const getStorageArgs: ZodOptional<ZodObject<{
    keys: ZodArray<ZodString, "many">;
}, "strip", ZodTypeAny, {
    keys: string[];
}, {
    keys: string[];
}>>[];
declare function getStorage(args: AsyncCallback<GetStorageReturns> & TypeOf<typeof getStorageArgs[0]>): Promise<GetStorageReturns>;

declare function getStorageInfo(args?: AsyncCallback<StorageInfo>): Promise<StorageInfo>;

declare const removeStorageArgs: ZodOptional<ZodObject<{
    keys: ZodArray<ZodString, "many">;
}, "strip", ZodTypeAny, {
    keys: string[];
}, {
    keys: string[];
}>>[];
declare function removeStorage(args: AsyncCallback<RemoveStorageReturns> & TypeOf<typeof removeStorageArgs[0]>): Promise<RemoveStorageReturns>;

declare const clearStorageArgs: ZodOptional<ZodObject<{
    prefix: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    prefix?: string | undefined;
}, {
    prefix?: string | undefined;
}>>[];
declare function clearStorage(args: AsyncVoidCallback & TypeOf<typeof clearStorageArgs[0]>): Promise<void>;

declare const getUserInfoArgs: ZodOptional<ZodObject<{
    avatarType: ZodOptional<ZodEnum<["small", "normal", "large"]>>;
}, "strip", ZodTypeAny, {
    avatarType?: "normal" | "small" | "large" | undefined;
}, {
    avatarType?: "normal" | "small" | "large" | undefined;
}>>[];
declare function getUserInfo(args?: AsyncCallback<GetUserInfoReturns> & TypeOf<typeof getUserInfoArgs[0]>): Promise<GetUserInfoReturns>;

declare function getNetworkType(args?: AsyncCallback<GetNetworkTypeReturns>): Promise<GetNetworkTypeReturns>;

declare const onNetworkStatusChangeArgs: ZodFunction<ZodTuple<[ZodObject<{
    isConnected: ZodBoolean;
    networkType: ZodEnum<["none", "wifi", "cellular", "unknown"]>;
}, "strip", ZodTypeAny, {
    isConnected: boolean;
    networkType: "none" | "unknown" | "wifi" | "cellular";
}, {
    isConnected: boolean;
    networkType: "none" | "unknown" | "wifi" | "cellular";
}>], ZodUnknown>, ZodVoid>[];
declare function onNetworkStatusChange(args: TypeOf<typeof onNetworkStatusChangeArgs[0]>): void;

declare const startBeaconDiscoveryArgs: ZodOptional<ZodObject<{
    scanningType: ZodOptional<ZodDefault<ZodEffects<ZodNumber, number, number>>>;
    expire: ZodOptional<ZodNumber>;
    monitorInterval: ZodOptional<ZodNumber>;
    domain: ZodOptional<ZodString>;
    scanConfig: ZodOptional<ZodObject<{
        scanTime: ZodOptional<ZodNumber>;
        timeBetweenScan: ZodOptional<ZodNumber>;
        beaconTimeout: ZodOptional<ZodNumber>;
        delayCheckConnectedTimeout: ZodOptional<ZodNumber>;
        beaconConnectedTimeout: ZodOptional<ZodNumber>;
    }, "strip", ZodTypeAny, {
        scanTime?: number | undefined;
        timeBetweenScan?: number | undefined;
        beaconTimeout?: number | undefined;
        delayCheckConnectedTimeout?: number | undefined;
        beaconConnectedTimeout?: number | undefined;
    }, {
        scanTime?: number | undefined;
        timeBetweenScan?: number | undefined;
        beaconTimeout?: number | undefined;
        delayCheckConnectedTimeout?: number | undefined;
        beaconConnectedTimeout?: number | undefined;
    }>>;
    items: ZodOptional<ZodArray<ZodObject<{
        id: ZodOptional<ZodString>;
        distance: ZodOptional<ZodNumber>;
        monitor: ZodOptional<ZodObject<{
            enable: ZodOptional<ZodBoolean>;
            movingRange: ZodOptional<ZodNumber>;
        }, "strip", ZodTypeAny, {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        }, {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        }>>;
    }, "strip", ZodTypeAny, {
        id?: string | undefined;
        distance?: number | undefined;
        monitor?: {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        } | undefined;
    }, {
        id?: string | undefined;
        distance?: number | undefined;
        monitor?: {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        } | undefined;
    }>, "many">>;
    scanFromSource: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    scanningType?: number | undefined;
    expire?: number | undefined;
    monitorInterval?: number | undefined;
    domain?: string | undefined;
    scanConfig?: {
        scanTime?: number | undefined;
        timeBetweenScan?: number | undefined;
        beaconTimeout?: number | undefined;
        delayCheckConnectedTimeout?: number | undefined;
        beaconConnectedTimeout?: number | undefined;
    } | undefined;
    items?: {
        id?: string | undefined;
        distance?: number | undefined;
        monitor?: {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        } | undefined;
    }[] | undefined;
    scanFromSource?: string | undefined;
}, {
    scanningType?: number | undefined;
    expire?: number | undefined;
    monitorInterval?: number | undefined;
    domain?: string | undefined;
    scanConfig?: {
        scanTime?: number | undefined;
        timeBetweenScan?: number | undefined;
        beaconTimeout?: number | undefined;
        delayCheckConnectedTimeout?: number | undefined;
        beaconConnectedTimeout?: number | undefined;
    } | undefined;
    items?: {
        id?: string | undefined;
        distance?: number | undefined;
        monitor?: {
            enable?: boolean | undefined;
            movingRange?: number | undefined;
        } | undefined;
    }[] | undefined;
    scanFromSource?: string | undefined;
}>>[];
declare function startBeaconDiscovery(args: AsyncCallback<boolean> & TypeOf<typeof startBeaconDiscoveryArgs[0]>): Promise<boolean>;

declare function stopBeaconDiscovery(args: AsyncCallback<boolean>): Promise<boolean>;

declare function getBeacons(args?: AsyncCallback<GetBeaconDiscoveryReturns>): Promise<GetBeaconDiscoveryReturns>;

declare function closeApp(args?: AsyncVoidCallback): Promise<void>;

declare function scanQRCode(args?: AsyncCallback<ScanQRCodeReturns>): Promise<ScanQRCodeReturns>;

declare const openProfileArgs: ZodOptional<ZodObject<{
    id: ZodString;
    type: ZodEnum<["user", "oa", "aliasOA"]>;
    sourceId: ZodOptional<ZodAny>;
    sourceIndex: ZodOptional<ZodAny>;
}, "strip", ZodTypeAny, {
    sourceId?: any;
    sourceIndex?: any;
    type: "user" | "oa" | "aliasOA";
    id: string;
}, {
    sourceId?: any;
    sourceIndex?: any;
    type: "user" | "oa" | "aliasOA";
    id: string;
}>>[];
declare function openProfile(args: AsyncVoidCallback & TypeOf<typeof openProfileArgs[0]>): Promise<void>;

declare const openChatArgs: ZodOptional<ZodObject<{
    id: ZodString;
    type: ZodEnum<["user", "oa"]>;
    sourceId: ZodOptional<ZodAny>;
    sourceIndex: ZodOptional<ZodAny>;
    message: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    message?: string | undefined;
    sourceId?: any;
    sourceIndex?: any;
    type: "user" | "oa";
    id: string;
}, {
    message?: string | undefined;
    sourceId?: any;
    sourceIndex?: any;
    type: "user" | "oa";
    id: string;
}>>[];
declare function openChat(args: AsyncVoidCallback & TypeOf<typeof openChatArgs[0]>): Promise<void>;

declare const openPostFeedArgs: ZodUnion<[ZodObject<{
    type: ZodEnum<["image"]>;
    data: ZodObject<{
        imageUrl: ZodOptional<ZodString>;
    }, "strip", ZodTypeAny, {
        imageUrl?: string | undefined;
    }, {
        imageUrl?: string | undefined;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        imageUrl?: string | undefined;
    };
    type: "image";
}, {
    data: {
        imageUrl?: string | undefined;
    };
    type: "image";
}>, ZodObject<{
    type: ZodEnum<["link"]>;
    data: ZodObject<{
        link: ZodString;
        title: ZodOptional<ZodString>;
        thumb: ZodOptional<ZodString>;
        description: ZodOptional<ZodDefault<ZodString>>;
    }, "strip", ZodTypeAny, {
        title?: string | undefined;
        thumb?: string | undefined;
        description?: string | undefined;
        link: string;
    }, {
        title?: string | undefined;
        thumb?: string | undefined;
        description?: string | undefined;
        link: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        title?: string | undefined;
        thumb?: string | undefined;
        description?: string | undefined;
        link: string;
    };
    type: "link";
}, {
    data: {
        title?: string | undefined;
        thumb?: string | undefined;
        description?: string | undefined;
        link: string;
    };
    type: "link";
}>, ZodObject<{
    type: ZodEnum<["profile"]>;
    data: ZodObject<{
        id: ZodOptional<ZodString>;
    }, "strip", ZodTypeAny, {
        id?: string | undefined;
    }, {
        id?: string | undefined;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        id?: string | undefined;
    };
    type: "profile";
}, {
    data: {
        id?: string | undefined;
    };
    type: "profile";
}>]>[];
declare function openPostFeed(args: AsyncCallback<OpenPostFeedReturns> & TypeOf<typeof openPostFeedArgs[0]>): Promise<OpenPostFeedReturns>;

declare const followOAArgs: ZodOptional<ZodObject<{
    id: ZodString;
    showDialogConfirm: ZodOptional<ZodBoolean>;
}, "strip", ZodTypeAny, {
    showDialogConfirm?: boolean | undefined;
    id: string;
}, {
    showDialogConfirm?: boolean | undefined;
    id: string;
}>>[];
declare function followOA(args: AsyncVoidCallback & TypeOf<typeof followOAArgs[0]>): Promise<void>;

declare const unfollowOAArgs: ZodOptional<ZodObject<{
    id: ZodString;
}, "strip", ZodTypeAny, {
    id: string;
}, {
    id: string;
}>>[];
declare function unfollowOA(args: AsyncVoidCallback & TypeOf<typeof unfollowOAArgs[0]>): Promise<void>;

declare const openShareSheetArgs: ZodUnion<[ZodObject<{
    type: ZodEnum<["image"]>;
    data: ZodObject<{
        imageUrl: ZodString;
        imageUrls: ZodOptional<ZodArray<ZodString, "many">>;
    }, "strip", ZodTypeAny, {
        imageUrls?: string[] | undefined;
        imageUrl: string;
    }, {
        imageUrls?: string[] | undefined;
        imageUrl: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        imageUrls?: string[] | undefined;
        imageUrl: string;
    };
    type: "image";
}, {
    data: {
        imageUrls?: string[] | undefined;
        imageUrl: string;
    };
    type: "image";
}>, ZodObject<{
    type: ZodEnum<["link"]>;
    data: ZodObject<{
        link: ZodString;
        chatOnly: ZodOptional<ZodBoolean>;
    }, "strip", ZodTypeAny, {
        chatOnly?: boolean | undefined;
        link: string;
    }, {
        chatOnly?: boolean | undefined;
        link: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        chatOnly?: boolean | undefined;
        link: string;
    };
    type: "link";
}, {
    data: {
        chatOnly?: boolean | undefined;
        link: string;
    };
    type: "link";
}>, ZodObject<{
    type: ZodEnum<["oa"]>;
    data: ZodObject<{
        id: ZodString;
    }, "strip", ZodTypeAny, {
        id: string;
    }, {
        id: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        id: string;
    };
    type: "oa";
}, {
    data: {
        id: string;
    };
    type: "oa";
}>, ZodObject<{
    type: ZodEnum<["gif"]>;
    data: ZodObject<{
        gifUrl: ZodString;
        imageUrl: ZodOptional<ZodString>;
        width: ZodOptional<ZodNumber>;
        height: ZodOptional<ZodNumber>;
    }, "strip", ZodTypeAny, {
        imageUrl?: string | undefined;
        width?: number | undefined;
        height?: number | undefined;
        gifUrl: string;
    }, {
        imageUrl?: string | undefined;
        width?: number | undefined;
        height?: number | undefined;
        gifUrl: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        imageUrl?: string | undefined;
        width?: number | undefined;
        height?: number | undefined;
        gifUrl: string;
    };
    type: "gif";
}, {
    data: {
        imageUrl?: string | undefined;
        width?: number | undefined;
        height?: number | undefined;
        gifUrl: string;
    };
    type: "gif";
}>, ZodObject<{
    type: ZodEnum<["video"]>;
    data: ZodObject<{
        videoThumb: ZodString;
        videoUrl: ZodString;
        width: ZodOptional<ZodNumber>;
        height: ZodOptional<ZodNumber>;
    }, "strip", ZodTypeAny, {
        width?: number | undefined;
        height?: number | undefined;
        videoThumb: string;
        videoUrl: string;
    }, {
        width?: number | undefined;
        height?: number | undefined;
        videoThumb: string;
        videoUrl: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        width?: number | undefined;
        height?: number | undefined;
        videoThumb: string;
        videoUrl: string;
    };
    type: "video";
}, {
    data: {
        width?: number | undefined;
        height?: number | undefined;
        videoThumb: string;
        videoUrl: string;
    };
    type: "video";
}>, ZodObject<{
    type: ZodEnum<["zmp", "zmp_deep_link"]>;
    data: ZodObject<{
        title: ZodString;
        thumbnail: ZodString;
        path: ZodOptional<ZodString>;
        description: ZodOptional<ZodDefault<ZodString>>;
    }, "strip", ZodTypeAny, {
        path?: string | undefined;
        description?: string | undefined;
        title: string;
        thumbnail: string;
    }, {
        path?: string | undefined;
        description?: string | undefined;
        title: string;
        thumbnail: string;
    }>;
}, "strip", ZodTypeAny, {
    data: {
        path?: string | undefined;
        description?: string | undefined;
        title: string;
        thumbnail: string;
    };
    type: "zmp" | "zmp_deep_link";
}, {
    data: {
        path?: string | undefined;
        description?: string | undefined;
        title: string;
        thumbnail: string;
    };
    type: "zmp" | "zmp_deep_link";
}>]>[];
declare function openShareSheet(args: AsyncCallback<OpenShareSheetReturns> & TypeOf<typeof openShareSheetArgs[0]>): Promise<OpenShareSheetReturns>;

declare function requestCameraPermission(args?: AsyncCallback<RequestCameraPermissionReturns>): Promise<RequestCameraPermissionReturns>;

declare const createShortcutArgs: ZodOptional<ZodObject<{
    params: ZodOptional<ZodRecord<ZodString, ZodString>>;
}, "strip", ZodTypeAny, {
    params?: Record<string, string> | undefined;
}, {
    params?: Record<string, string> | undefined;
}>>[];
declare function createShortcut(args?: AsyncCallback<any> & TypeOf<typeof createShortcutArgs[0]>): Promise<any>;

declare const openBioAuthenticationArgs: ZodOptional<ZodObject<{
    secretData: ZodString;
    ui: ZodOptional<ZodObject<{
        title: ZodOptional<ZodDefault<ZodString>>;
        subTitle: ZodOptional<ZodDefault<ZodString>>;
        negativeButtonText: ZodOptional<ZodDefault<ZodString>>;
    }, "strip", ZodTypeAny, {
        title?: string | undefined;
        subTitle?: string | undefined;
        negativeButtonText?: string | undefined;
    }, {
        title?: string | undefined;
        subTitle?: string | undefined;
        negativeButtonText?: string | undefined;
    }>>;
    requireFingerprint: ZodOptional<ZodDefault<ZodBoolean>>;
}, "strip", ZodTypeAny, {
    ui?: {
        title?: string | undefined;
        subTitle?: string | undefined;
        negativeButtonText?: string | undefined;
    } | undefined;
    requireFingerprint?: boolean | undefined;
    secretData: string;
}, {
    ui?: {
        title?: string | undefined;
        subTitle?: string | undefined;
        negativeButtonText?: string | undefined;
    } | undefined;
    requireFingerprint?: boolean | undefined;
    secretData: string;
}>>[];
declare function openBioAuthentication(args: AsyncCallback<OpenBioAuthenticationReturns> & TypeOf<typeof openBioAuthenticationArgs[0]>): Promise<OpenBioAuthenticationReturns>;

declare function checkStateBioAuthentication(args?: AsyncCallback<CheckStateBioAuthenticationReturns>): Promise<CheckStateBioAuthenticationReturns>;

declare const showToastArgs: ZodOptional<ZodObject<{
    message: ZodString;
}, "strip", ZodTypeAny, {
    message: string;
}, {
    message: string;
}>>[];
declare function showToast(args: AsyncVoidCallback & TypeOf<typeof showToastArgs[0]>): Promise<void>;

declare function hideKeyboard(args?: AsyncVoidCallback): Promise<void>;

declare const openPhoneArgs: ZodObject<{
    phoneNumber: ZodString;
}, "strip", ZodTypeAny, {
    phoneNumber: string;
}, {
    phoneNumber: string;
}>[];
declare function openPhone(args: AsyncVoidCallback & TypeOf<typeof openPhoneArgs[0]>): Promise<void>;

declare const openSMSArgs: ZodObject<{
    content: ZodString;
    phoneNumber: ZodString;
}, "strip", ZodTypeAny, {
    content: string;
    phoneNumber: string;
}, {
    content: string;
    phoneNumber: string;
}>[];
declare function openSMS(args: AsyncVoidCallback & TypeOf<typeof openSMSArgs[0]>): Promise<void>;

declare const viewOAQrArgs: ZodObject<{
    id: ZodString;
    displayName: ZodOptional<ZodDefault<ZodString>>;
}, "strip", ZodTypeAny, {
    displayName?: string | undefined;
    id: string;
}, {
    displayName?: string | undefined;
    id: string;
}>[];
declare function viewOAQr(args: AsyncVoidCallback & TypeOf<typeof viewOAQrArgs[0]>): Promise<void>;

declare const keepScreenArgs: ZodObject<{
    keepScreenOn: ZodBoolean;
}, "strip", ZodTypeAny, {
    keepScreenOn: boolean;
}, {
    keepScreenOn: boolean;
}>[];
declare function keepScreen(args: AsyncCallback<KeepScreenReturns> & TypeOf<typeof keepScreenArgs[0]>): Promise<void>;

declare function onKeepScreen(args?: AsyncVoidCallback): Promise<void>;

declare function offKeepScreen(args?: AsyncVoidCallback): Promise<void>;

declare const saveImageToGalleryArgs: ZodOptional<ZodObject<{
    imageBase64Data: ZodOptional<ZodString>;
    imageUrl: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    imageUrl?: string | undefined;
    imageBase64Data?: string | undefined;
}, {
    imageUrl?: string | undefined;
    imageBase64Data?: string | undefined;
}>>[];
declare function saveImageToGallery(args: AsyncVoidCallback & TypeOf<typeof saveImageToGalleryArgs[0]>): Promise<void>;

declare const openMiniAppArgs: ZodObject<{
    appId: ZodString;
    path: ZodOptional<ZodString>;
    params: ZodOptional<ZodRecord<ZodString, ZodString>>;
}, "strip", ZodTypeAny, {
    path?: string | undefined;
    params?: Record<string, string> | undefined;
    appId: string;
}, {
    path?: string | undefined;
    params?: Record<string, string> | undefined;
    appId: string;
}>[];
declare function openMiniApp(args: AsyncVoidCallback & TypeOf<typeof openMiniAppArgs[0]>): Promise<void>;

declare const vibrateArgs: ZodObject<{
    type: ZodDefault<ZodEnum<["oneShot"]>>;
    milliseconds: ZodOptional<ZodNumber>;
}, "strip", ZodTypeAny, {
    milliseconds?: number | undefined;
    type: "oneShot";
}, {
    type?: "oneShot" | undefined;
    milliseconds?: number | undefined;
}>[];
declare function vibrate(args?: AsyncVoidCallback & TypeOf<typeof vibrateArgs[0]>): Promise<void>;

declare const openWebviewArgs: ZodObject<{
    url: ZodString;
}, "strip", ZodTypeAny, {
    url: string;
}, {
    url: string;
}>[];
declare function openWebview(args: AsyncCallback<OpenWebviewReturns> & TypeOf<typeof openWebviewArgs[0]>): Promise<void>;

declare function getRouteParams(): Record<string, string>;

declare function getAppInfo(args?: AsyncCallback<GetAppInfoReturns>): Promise<GetAppInfoReturns>;

declare const sendDataToPreviousMiniAppArgs: ZodObject<{
    data: ZodAny;
}, "strip", ZodTypeAny, {
    data?: any;
}, {
    data?: any;
}>[];
declare function sendDataToPreviousMiniApp(args: AsyncVoidCallback & TypeOf<typeof sendDataToPreviousMiniAppArgs[0]>): Promise<void>;

declare function getPhoneNumber(args?: AsyncCallback<GetPhoneNumberReturns>): Promise<GetPhoneNumberReturns>;

declare const openProfilePickerArgs: ZodObject<{
    maxProfile: ZodDefault<ZodOptional<ZodNumber>>;
}, "strip", ZodTypeAny, {
    maxProfile: number;
}, {
    maxProfile?: number | undefined;
}>[];
declare function openProfilePicker(args?: AsyncCallback<OpenProfilePickerReturns> & TypeOf<typeof openProfilePickerArgs[0]>): Promise<OpenProfilePickerReturns>;

declare const connectWifiArgs: ZodObject<{
    SSID: ZodString;
    password: ZodOptional<ZodString>;
    hiddenSSID: ZodOptional<ZodBoolean>;
}, "strip", ZodTypeAny, {
    password?: string | undefined;
    hiddenSSID?: boolean | undefined;
    SSID: string;
}, {
    password?: string | undefined;
    hiddenSSID?: boolean | undefined;
    SSID: string;
}>[];
declare function connectWifi(args: AsyncVoidCallback & TypeOf<typeof connectWifiArgs[0]>): Promise<void>;

declare const openMediaPickerArgs: ZodObject<{
    type: ZodEnum<["video", "photo", "file", "zcamera", "zcamera_photo", "zcamera_video", "zcamera_scan"]>;
    serverUploadUrl: ZodString;
    maxItemSize: ZodOptional<ZodNumber>;
    editView: ZodOptional<ZodObject<{
        enable: ZodOptional<ZodBoolean>;
        aspectRatio: ZodOptional<ZodString>;
    }, "strip", ZodTypeAny, {
        enable?: boolean | undefined;
        aspectRatio?: string | undefined;
    }, {
        enable?: boolean | undefined;
        aspectRatio?: string | undefined;
    }>>;
    silentRequest: ZodOptional<ZodBoolean>;
    maxSelectItem: ZodOptional<ZodNumber>;
}, "strip", ZodTypeAny, {
    maxItemSize?: number | undefined;
    editView?: {
        enable?: boolean | undefined;
        aspectRatio?: string | undefined;
    } | undefined;
    silentRequest?: boolean | undefined;
    maxSelectItem?: number | undefined;
    type: "video" | "zcamera" | "zcamera_photo" | "zcamera_video" | "zcamera_scan" | "photo" | "file";
    serverUploadUrl: string;
}, {
    maxItemSize?: number | undefined;
    editView?: {
        enable?: boolean | undefined;
        aspectRatio?: string | undefined;
    } | undefined;
    silentRequest?: boolean | undefined;
    maxSelectItem?: number | undefined;
    type: "video" | "zcamera" | "zcamera_photo" | "zcamera_video" | "zcamera_scan" | "photo" | "file";
    serverUploadUrl: string;
}>[];
declare function openMediaPicker(args: AsyncCallback<OpenMediaPickerReturns> & TypeOf<typeof openMediaPickerArgs[0]>): Promise<OpenMediaPickerReturns>;

declare const getShareableLinkArgs: ZodObject<{
    title: ZodString;
    description: ZodDefault<ZodString>;
    thumbnail: ZodOptional<ZodString>;
    path: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    path?: string | undefined;
    thumbnail?: string | undefined;
    title: string;
    description: string;
}, {
    path?: string | undefined;
    description?: string | undefined;
    thumbnail?: string | undefined;
    title: string;
}>[];
declare function getShareableLink(args: AsyncCallback<string> & TypeOf<typeof getShareableLinkArgs[0]>): Promise<string>;

declare function closeLoading(args?: AsyncVoidCallback): Promise<void>;

declare function requestUpdateZalo(args?: AsyncVoidCallback): Promise<void>;

declare const onConfirmToExitArgs: ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>[];
declare function onConfirmToExit(args: TypeOf<typeof onConfirmToExitArgs[0]>): void;

declare function offConfirmToExit(): void;

declare function getDeviceId(): string;

declare function getDeviceIdAsync(args?: AsyncCallback<string>): Promise<string>;

declare function getContext(): ContextInfo | null;

declare function getContextAsync(args?: AsyncCallback<ContextInfo>): Promise<ContextInfo | null>;

declare function getAuthCode(args?: AsyncCallback<GetAuthCodeReturns>): Promise<GetAuthCodeReturns>;

declare function getZPIToken(args?: AsyncCallback<GetZPITokenReturns>): Promise<GetZPITokenReturns>;

declare const setAccessTokenArgs: ZodString[];
declare function setAccessToken(args: TypeOf<typeof setAccessTokenArgs[0]>): void;

declare const openOutAppArgs: ZodObject<{
    url: ZodString;
}, "strip", ZodTypeAny, {
    url: string;
}, {
    url: string;
}>[];
declare function openOutApp(args: TypeOf<typeof openOutAppArgs[0]>): Promise<void>;

declare const chooseImageArgs: ZodObject<{
    count: ZodDefault<ZodOptional<ZodNumber>>;
    sourceType: ZodOptional<ZodDefault<ZodArray<ZodEnum<["album", "camera"]>, "many">>>;
    cameraType: ZodOptional<ZodDefault<ZodEnum<["back", "front"]>>>;
}, "strip", ZodTypeAny, {
    sourceType?: ("album" | "camera")[] | undefined;
    cameraType?: "back" | "front" | undefined;
    count: number;
}, {
    count?: number | undefined;
    sourceType?: ("album" | "camera")[] | undefined;
    cameraType?: "back" | "front" | undefined;
}>[];
declare function chooseImage(args: AsyncCallback<ChooseImageReturns> & TypeOf<typeof chooseImageArgs[0]>): Promise<ChooseImageReturns>;

declare function getLocation(args?: AsyncCallback<GetLocationReturns>): Promise<GetLocationReturns>;

declare const onCallbackDataArgs: ZodFunction<ZodTuple<[ZodObject<{
    data: ZodAny;
}, "strip", ZodTypeAny, {
    data?: any;
}, {
    data?: any;
}>], ZodUnknown>, ZodVoid>[];
declare function onCallbackData(args: TypeOf<typeof onCallbackDataArgs[0]>): void;

declare const createOrderArgs: ZodObject<{
    amount: ZodUnion<[ZodString, ZodNumber]>;
    item: ZodArray<ZodRecord<ZodString, ZodAny>, "many">;
    desc: ZodString;
    extradata: ZodOptional<ZodAny>;
    method: ZodOptional<ZodEnum<["MOMO", "ZALOPAY", "MOMO_SANDBOX", "ZALOPAY_SANDBOX", "CC", "CC_SANDBOX", "ATM", "ATM_SANDBOX", "VNPAY", "VNPAY_SANDBOX"]>>;
}, "strip", ZodTypeAny, {
    method?: "ZALOPAY" | "MOMO" | "ZALOPAY_SANDBOX" | "MOMO_SANDBOX" | "ATM" | "ATM_SANDBOX" | "CC" | "CC_SANDBOX" | "VNPAY" | "VNPAY_SANDBOX" | undefined;
    extradata?: any;
    desc: string;
    amount: string | number;
    item: Record<string, any>[];
}, {
    method?: "ZALOPAY" | "MOMO" | "ZALOPAY_SANDBOX" | "MOMO_SANDBOX" | "ATM" | "ATM_SANDBOX" | "CC" | "CC_SANDBOX" | "VNPAY" | "VNPAY_SANDBOX" | undefined;
    extradata?: any;
    desc: string;
    amount: string | number;
    item: Record<string, any>[];
}>[];
declare function createOrder(args: AsyncCallback<CreateOrderReturns> & TypeOf<(typeof createOrderArgs)[0]>): Promise<CreateOrderReturns>;

declare const checkTransactionArgs: ZodObject<{
    data: ZodUnion<[ZodString, ZodRecord<ZodString, ZodString>]>;
}, "strip", ZodTypeAny, {
    data: string | Record<string, string>;
}, {
    data: string | Record<string, string>;
}>[];
declare function checkTransaction(args: AsyncCallback<CheckTransactionReturns> & TypeOf<typeof checkTransactionArgs[0]>): Promise<CheckTransactionReturns>;

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 */
declare class EventEmitter<
  EventTypes extends EventEmitter.ValidEventTypes = string | symbol,
  Context extends any = any
> {
  static prefixed: string | boolean;

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   */
  eventNames(): Array<EventEmitter.EventNames<EventTypes>>;

  /**
   * Return the listeners registered for a given event.
   */
  listeners<T extends EventEmitter.EventNames<EventTypes>>(
    event: T
  ): Array<EventEmitter.EventListener<EventTypes, T>>;

  /**
   * Return the number of listeners listening to a given event.
   */
  listenerCount(event: EventEmitter.EventNames<EventTypes>): number;

  /**
   * Calls each of the listeners registered for a given event.
   */
  emit<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    ...args: EventEmitter.EventArgs<EventTypes, T>
  ): boolean;

  /**
   * Add a listener for a given event.
   */
  on<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;
  addListener<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;

  /**
   * Add a one-time listener for a given event.
   */
  once<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;

  /**
   * Remove the listeners of a given event.
   */
  removeListener<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn?: EventEmitter.EventListener<EventTypes, T>,
    context?: Context,
    once?: boolean
  ): this;
  off<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn?: EventEmitter.EventListener<EventTypes, T>,
    context?: Context,
    once?: boolean
  ): this;

  /**
   * Remove all listeners, or those of the specified event.
   */
  removeAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;
}

declare namespace EventEmitter {
  export interface ListenerFn<Args extends any[] = any[]> {
    (...args: Args): void;
  }

  export interface EventEmitterStatic {
    new <
      EventTypes extends ValidEventTypes = string | symbol,
      Context = any
    >(): EventEmitter<EventTypes, Context>;
  }

  /**
   * `object` should be in either of the following forms:
   * ```
   * interface EventTypes {
   *   'event-with-parameters': any[]
   *   'event-with-example-handler': (...args: any[]) => void
   * }
   * ```
   */
  export type ValidEventTypes = string | symbol | object;

  export type EventNames<T extends ValidEventTypes> = T extends string | symbol
    ? T
    : keyof T;

  export type ArgumentMap<T extends object> = {
    [K in keyof T]: T[K] extends (...args: any[]) => void
      ? Parameters<T[K]>
      : T[K] extends any[]
      ? T[K]
      : any[];
  };

  export type EventListener<
    T extends ValidEventTypes,
    K extends EventNames<T>
  > = T extends string | symbol
    ? (...args: any[]) => void
    : (
        ...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]
      ) => void;

  export type EventArgs<
    T extends ValidEventTypes,
    K extends EventNames<T>
  > = Parameters<EventListener<T, K>>;

  export const EventEmitter: EventEmitterStatic;
}

declare const events: EventEmitter;

declare const setAndroidBottomNavigationBarArgs: ZodOptional<ZodObject<{
    hide: ZodOptional<ZodDefault<ZodBoolean>>;
}, "strip", ZodTypeAny, {
    hide?: boolean | undefined;
}, {
    hide?: boolean | undefined;
}>>[];
declare function setAndroidBottomNavigationBar(args: AsyncVoidCallback & TypeOf<typeof setAndroidBottomNavigationBarArgs[0]>): Promise<void>;

declare const setIOSBottomSafeAreaArgs: ZodOptional<ZodObject<{
    hide: ZodOptional<ZodDefault<ZodBoolean>>;
}, "strip", ZodTypeAny, {
    hide?: boolean | undefined;
}, {
    hide?: boolean | undefined;
}>>[];
declare function setIOSBottomSafeArea(args: AsyncVoidCallback & TypeOf<typeof setIOSBottomSafeAreaArgs[0]>): Promise<void>;

declare const setStatusBarArgs: ZodOptional<ZodObject<{
    type: ZodOptional<ZodDefault<ZodEnum<["normal", "hidden", "transparent"]>>>;
    color: ZodOptional<ZodString>;
}, "strip", ZodTypeAny, {
    type?: "hidden" | "transparent" | "normal" | undefined;
    color?: string | undefined;
}, {
    type?: "hidden" | "transparent" | "normal" | undefined;
    color?: string | undefined;
}>>[];
declare function setStatusBar(args: AsyncVoidCallback & TypeOf<typeof setStatusBarArgs[0]>): Promise<void>;

declare const configAppViewArgs: ZodObject<{
    headerTextColor: ZodOptional<ZodEnum<["black", "white"]>>;
    headerColor: ZodOptional<ZodString>;
    actionBar: ZodOptional<ZodObject<{
        hide: ZodOptional<ZodBoolean>;
        title: ZodOptional<ZodString>;
        leftButton: ZodOptional<ZodEnum<["back", "none"]>>;
        textAlign: ZodOptional<ZodDefault<ZodEnum<["left", "center"]>>>;
    }, "strip", ZodTypeAny, {
        title?: string | undefined;
        hide?: boolean | undefined;
        leftButton?: "none" | "back" | undefined;
        textAlign?: "left" | "center" | undefined;
    }, {
        title?: string | undefined;
        hide?: boolean | undefined;
        leftButton?: "none" | "back" | undefined;
        textAlign?: "left" | "center" | undefined;
    }>>;
    statusBarType: ZodOptional<ZodEnum<["normal", "hidden", "transparent"]>>;
    hideAndroidBottomNavigationBar: ZodOptional<ZodBoolean>;
    hideIOSSafeAreaBottom: ZodOptional<ZodBoolean>;
}, "strip", ZodTypeAny, {
    headerTextColor?: "black" | "white" | undefined;
    headerColor?: string | undefined;
    actionBar?: {
        title?: string | undefined;
        hide?: boolean | undefined;
        leftButton?: "none" | "back" | undefined;
        textAlign?: "left" | "center" | undefined;
    } | undefined;
    statusBarType?: "hidden" | "transparent" | "normal" | undefined;
    hideAndroidBottomNavigationBar?: boolean | undefined;
    hideIOSSafeAreaBottom?: boolean | undefined;
}, {
    headerTextColor?: "black" | "white" | undefined;
    headerColor?: string | undefined;
    actionBar?: {
        title?: string | undefined;
        hide?: boolean | undefined;
        leftButton?: "none" | "back" | undefined;
        textAlign?: "left" | "center" | undefined;
    } | undefined;
    statusBarType?: "hidden" | "transparent" | "normal" | undefined;
    hideAndroidBottomNavigationBar?: boolean | undefined;
    hideIOSSafeAreaBottom?: boolean | undefined;
}>[];
declare function configAppView(args: AsyncVoidCallback & TypeOf<typeof configAppViewArgs[0]>): Promise<void>;

declare const createOrderIAPArgs: ZodObject<{
    productId: ZodString;
    payType: ZodOptional<ZodEnum<["ONETIME", "SUBSCRIPTION"]>>;
    prorationMode: ZodOptional<ZodDefault<ZodEnum<["DEFERRED", "IMMEDIATE_AND_CHARGE_FULL_PRICE"]>>>;
    method: ZodOptional<ZodEnum<["IAP", "IAP_SANDBOX"]>>;
}, "strip", ZodTypeAny, {
    method?: "IAP" | "IAP_SANDBOX" | undefined;
    payType?: "SUBSCRIPTION" | "ONETIME" | undefined;
    prorationMode?: "DEFERRED" | "IMMEDIATE_AND_CHARGE_FULL_PRICE" | undefined;
    productId: string;
}, {
    method?: "IAP" | "IAP_SANDBOX" | undefined;
    payType?: "SUBSCRIPTION" | "ONETIME" | undefined;
    prorationMode?: "DEFERRED" | "IMMEDIATE_AND_CHARGE_FULL_PRICE" | undefined;
    productId: string;
}>[];
declare function createOrderIAP(args: AsyncCallback<CreateOrderIAPReturns> & TypeOf<typeof createOrderIAPArgs[0]>): Promise<CreateOrderIAPReturns>;

declare function minimizeApp(args?: AsyncVoidCallback): Promise<void>;

declare function openPermissionSetting(args?: AsyncVoidCallback): Promise<void>;

declare function favoriteApp(args?: AsyncVoidCallback): Promise<void>;

declare function openGroupList(args?: AsyncVoidCallback): Promise<void>;

declare function requestSendNotification(args?: AsyncVoidCallback): Promise<void>;

declare function addRating(args?: AsyncVoidCallback): Promise<void>;

declare const interactOAArgs: ZodObject<{
    oaId: ZodString;
}, "strip", ZodTypeAny, {
    oaId: string;
}, {
    oaId: string;
}>[];
declare function interactOA(args: AsyncVoidCallback & TypeOf<(typeof interactOAArgs)[0]>): Promise<void>;

export { Events as EventName, Events, addRating, checkStateBioAuthentication, checkTransaction, chooseImage, clearStorage, closeApp, closeLoading, configAppView, connectWifi, createOrder, createOrderIAP, createShortcut, events, favoriteApp, followOA, getAccessToken, getAppInfo, getAuthCode, getBeacons, getContext, getContextAsync, getDeviceId, getDeviceIdAsync, getLocation, getNetworkType, getPhoneNumber, getRouteParams, getShareableLink, getStorage, getStorageInfo, getSystemInfo, getUserInfo, getVersion, getZPIToken, hideKeyboard, interactOA, interactOA as interactOa, keepScreen, login, minimizeApp, offConfirmToExit, offKeepScreen, onCallbackData, onConfirmToExit, onKeepScreen, onNetworkStatusChange, openBioAuthentication, openChat, openGroupList, openMediaPicker, openMiniApp, openOutApp, openPermissionSetting, openPhone, openPostFeed, openProfile, openProfilePicker, openSMS, openShareSheet, openWebview, removeStorage, requestCameraPermission, requestSendNotification, requestUpdateZalo, saveImageToGallery, scanQRCode, sendDataToPreviousMiniApp, setAccessToken, setAndroidBottomNavigationBar, setIOSBottomSafeArea, setNavigationBarColor, setNavigationBarLeftButton, setNavigationBarTitle, setStatusBar, setStorage, showToast, startBeaconDiscovery, stopBeaconDiscovery, unfollowOA, vibrate, viewOAQr };
